Что такое реляционная база данных? В чем заключена основная идея реляционного подхода к построению баз данных?
	реляционная база данных представляет собой набор двухмерных таблиц. таблицы состоят из колонок и строк.
	каждая из которых содержит информацию об объектах определенного типа.
	Внутри таблиц могут быть наложены ограничения. между таблицами могут быть установлены связи.
	
	Основная идея реляционной модели – представить произвольную структуру данных в виде двумерных таблиц.
	
Что такое индексы? Какие виды индексов Вы знаете? Чем они отличаются?	
	Индекс - объект базы данных предназначенный для более быстрого поиска данных. так же могут служить для поддержки целостности данных.
	устанавливает соответствие между ключом  и строками таблицы, в которых этот ключ встречается.
	
	B-дерево - наиболее часто использующийся тип индекса
		пригоден для данных, которые можно отсортировать. 
		для типа данных должны быть определены операторы > >= < <=  = <>
		индексные записи B-дерева упакованы в страницы. В листовых страницах эти записи содержат индексируемые данные (ключи) и ссылки на строки таблицы
			частичный индекс - индекс с условием where
			покрывающий индекс - индекс сразу включающий данные из других колонок
			Кластерный индекс - физически сортирует таблицу (не во всех бд) - в postgre это одноразовая операция и все последующие данные будут записываться в конец таблицы
			Функциональный индекс - создается по произвольному выражению (хранит результат выражения)
 	
	GiST используется там где нельзя использовать операторы сравнения 
	подходит для хранения геоданных, текстовых документов
	
	
	GIN - обратный индекс
	для типов данных которые состоят из элементов. основное использование - создание полнотекстового поиска или ускорение поиска части текста
	
Есть три типа индексов, а именно:


Уникальный индекс (Unique Index): этот индекс не позволяет полю иметь повторяющиеся значения, если столбец индексируется уникально. 
Если первичный ключ определен, уникальный индекс может быть применен автоматически.

Кластеризованный индекс (Clustered Index): этот индекс меняет физический порядок таблицы и выполняет поиск на основе значений ключа. 
Каждая таблица может иметь только один кластеризованный индекс.

Некластеризованный индекс (Non-Clustered Index): не изменяет физический порядок таблицы и поддерживает логический порядок данных.
 Каждая таблица может иметь много некластеризованных индексов.	
 
 
При создании составного индекса сначала строится обычный индекс для его первой колонки,
 а потом уже на основе него строится индекс для второй колонки и так дальше.
Другими словами, колонки, по которым поиск выполняется чаще всего, должны стоять в составном индексе первыми.

=====================================================

Что такое статистика? Опишите применение статистик?	
		статистическая информация о содержимом таблиц в базе данных.
			Используется планировщиком для создания оптимального плана запроса.
			важно собирать свежую статистику после каждого качественного изменения таблиц.
			
Что такое транзакция? Какие уровни изоляции транзакций бывают? 
	Предотвращают случайную потерю данных или их искажение.
	
		По умолчанию в PostgreSQL уровень изоляции Read Committed.
		Такой уровень изоляции всегда позволяет видеть изменения внесённые успешно завершёнными транзакциями
		в оставшихся параллельно открытых транзакциях
		
		Serializable обеспечивает беспрепятственный доступ к базе данных транзакциям с SELECT запросами.
		Но для транзакций с запросами UPDATE и DELETE, уровень изоляции Serializable не допускает модификации одной и той же строки в рамках разных транзакций.

		Read uncommitted
		Минимальный уровень изоляции, гарантирует  только физическую целостность при записи данных.
		Процессы-читатели могут считывать данные незавершенной транзакции процесса-писателя.
		
		Repeatable read
		Повторное чтение данных вернет те же значения, что и в начале транзакции.
		При этом процессы-писатели могут вставлять новые записи, имеющие статус "фантома" при незавершенной транзакции.
		
нормализация бд
    атомарность
					БД нужна чтобы хранить утверждения о состоянии информационной системы.
			Ситуацию в которой утверждений о состоянии какой-то части системы больше чем одно мы считаем дублированием информации. (У вас эта ситуация называется "избыточность").
			Если есть дублирование информации, то возможна ситуация когда утверждения могут противоречить друг другу.
			 В этом случае БД неконсистентна и информационная система может работать некорректна.
			Нормализация БД - устранение дублирования информации в БД с целью достижения консистентности,
			 в первую очередь. Нормальные формы - это шаги которые нужно пройти на пути к консистентности (делай раз, делай два ...)
			Побочным эффектом нормализации является уменьшение размера БД.
			В случаях когда производительность важнее консистентности, 
			выполняют денормализацию БД (внесение избыточности) под определённые запросы, чтобы избежать объединений таблиц (JOIN).
			
			
			9 форм используют 3 + Нормальная форма Бойса — Кодда (BCNF)
			https://habr.com/ru/post/254773/
			
			
Первая нормальная форма (1NF) — нет повторяющихся групп в строках
Вторая нормальная форма (2NF) — каждое неключевое (поддерживающее) значение столбца зависит от всего первичного ключа
Третья нормальная форма (3NF) — каждое неключевое значение зависит только от первичного ключа и не имеет зависимости от другого неключевого значения столбца			
			
			
Подход Ральфа Кимбалла основывается на важности витрин данных, которые являются хранилищами данных,
 принадлежащих конкретным направлениям бизнеса. Хранилище данных — это просто сочетание различных витрин данных,
 которые облегчают отчетность и анализ. Проект хранилища данных по принципу Кимбалла использует подход «снизу вверх». - мегатаблицы olap
 
DIMENSIONAL MODELING (DM) — это метод структуры данных, оптимизированный для хранения данных в хранилище данных. 
Целью размерной модели является оптимизация базы данных для быстрого поиска данных. 
Концепция размерного моделирования была разработана Ральфом Кимбаллом и состоит из таблиц «факт» и «измерение».




Подход Билла Инмона основывается на том, что хранилище данных является централизованным хранилищем всех корпоративных данных.
 При таком подходе организация сначала создает нормализованную модель хранилища данных. Затем создаются витрины размерных данных на основе модели хранилища.
 Это известно как нисходящий подход к хранилищу данных.		oltp	
			
			
-================
В общих словах разницы никакой, но на отдельных наборах данных ресурсоемкость алгоритма и время его выполнения могут сильно варьироваться.

Nested loop - (сильно грубое описание) Пробегаем по таблице 1 и для каждой строки из нее смотрим какие строки из таблицы 2 ей подходят.
Обычно очень быстро дает первые строки результата (если конечно таблица 2 не гигантская, а единственная строка из первой таблицы,
 которая попадет в результат - последняя). Еще алгоритм, практически не требует дополнительной памяти для промежуточной работы и индекс во второй таблице может сильно помочь.

Hash join - Поскольку сравнивать каждую строку с каждой очень долго придумали шаманские танцы. 
Придумываем некую очень быстро вычислимую функцию от сравниваемых полей возвращающую результат от 1 до N.
 Просматриваем все строки таблицы 1 и раскладываем их в N корзин.
 Просматриваем таблицу 2 и для каждой строки проверяем только строки из подходящей корзины.
Достоинства - Общее количество операций сравнения гораздо меньше.
Недостатки - Можно оптимизировать только операции равенства, ибо для равных значений равны и значения hash функций, но ">" "<" уже не гарантируются. 
:( Если коллизии (совпадения hash при разных исходных данных) лягут так, что все строки попадут в одну корзину - то только лишняя работа.

--- hash masql
Hash Join - более эффективен при работе с большими наборами данных и даже тогда, когда таблицы не
отсортированы по столбцам, по которым производится соединение. Hash Join распараллеливается и
масштабируется лучше любого другого соединения и сильно выигрывает при большой производительности
информационных хранилищ.
Соединение происходит с использованием хеширования, вычесляя хеш записей из меньшей таблицы
(Build-таблица) и вставляя их в хеш-таблицу, затем обрабатывается большая таблица (Probe-таблица) по
одной записи, сканируя хеш-таблицу для поиска совпадений



Merge join - построен на том, что если множества упорядочены,
 то просматривать их целиком не обязательно можно последовательно идти по одному - потом по другому,
 затем опять по первому и так пока не надоест.
Недостатки - данные надо заранее упорядочить.
 А если использовать индекс при условии, 
 что таблички не влезают в кеш и будут постоянно вымываться приведет к большому числу операций ввода-вывода.			
			
			
			

----------- порядок выполнения запроса
FROM (выбор таблицы)
JOIN (комбинация с подходящими по условию данными из других таблиц)
WHERE (фильтрация строк)
GROUP BY (агрегирование данных)
HAVING (фильтрация агрегированных данных)
SELECT (возврат результирующего датасета)
ORDER BY (сортировка).


------
LATERAL аналог EXISTS, IN и SELECT (SELECT) FROM ...
То есть разрешается внутри соединения LATERAL ссылаться на поля внешнего запроса. Примеры использования:
// Соединение через SELECT:
SELECT *,
   (SELECT Count()
    FROM b
    WHERE a.id = b.id) AS Count
FROM a

// Соединение через JOIN:
SELECT *
FROM a
  INNER JOIN (
    SELECT b.id, Count() AS Count
    FROM b
    GROUP BY b.id ) AS b ON b.id = a.id;

// Соединение через LATERAL:
SELECT *
FROM a,
  LATERAL (
    SELECT Count() AS Count
    FROM b
    WHERE a.id = b.id ) AS b;

// Соединение хранимой процедуры, с ее вызовом на каждую запись из
// таблицы a и передачей полей записи в процедуру
SELECT *
FROM a,
  LATERAL (StoredProc (a.id)) AS b;
С хранимой процедурой в принципе все понятно - если бы не было LATERAL, 
то пришлось бы на таблицу "a" организовывать курсор и в цикле вызывать процедуру, скидывая результаты во временную таблицу. 
С подзапросами не все так просто. Легкие запросы, как тот, что я привел выше,
 оптимизатор сам в плане запросов преобразует и приведет к стандартным JOIN
 (таким образом здесь что SELECT в SELECT, что LATERAL будет только семантически отличаться от INNER JOIN). 
 Однако в сложных запросах, где подзапрос настолько сложен, что описание его через JOIN может привести к тому,
 что оптимизатор построит не самый эффективный план запроса, использование LATERAL может оказаться более эффективным и быстрым 
 (за счет того, что оптимизатор уведет подзапрос LATERAL в subquery и будет его выполнять на каждую строчку запроса). 
 Но стоит помнить, что LATERAL это не панацея - в любом случае стоит для таких запросов смотреть и анализировать планы запросов, 
 так как где то эффективнее будет использование JOIN, а где то как раз LATERAL. 
 В принципе LATERAL нужно всегда рассматривать как конструкцию SELECT в SELECT, но с разрешением возвращения не одного,
 а множества полей. В остальном эти обе конструкции обрабатываются оптимизатором одинаковым образом.
 
 
 ------
 “View” является визуальным представлением таблицы. Более того, View может включать в себя и представлять данные нескольких таблиц – это зависит от ситуации и отношений между ними.
 
 
 
 ---Хранимые процедуры похожи на определяемые пользователем функции (UDF).
 Основное различие заключается в том, что пользовательские функции можно использовать 
 как и любое другое выражение в SQL запросе,
 в то время как хранимые процедуры должны быть вызваны с помощью функции CALL: CALL процедур